<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C/C++,python," />










<meta name="description" content="背景遇到一个将字符串分割场景.以前从没有用c语言实现,都是使用python的split()函数,python处理起来很简单. split()方法语法： str.split(str=&amp;quot;&amp;quot;, num=string.count(str)). • str -- 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。 • num -- 分割次数。 返回分割后的字符串列表。">
<meta name="keywords" content="C&#x2F;C++,python">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言实现分割字符串">
<meta property="og:url" content="https://githubmota.github.io/2017/12/29/2017-12-29-Linux-C-Split/index.html">
<meta property="og:site_name" content="Mota&#39;s blog">
<meta property="og:description" content="背景遇到一个将字符串分割场景.以前从没有用c语言实现,都是使用python的split()函数,python处理起来很简单. split()方法语法： str.split(str=&amp;quot;&amp;quot;, num=string.count(str)). • str -- 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。 • num -- 分割次数。 返回分割后的字符串列表。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-07-02T08:16:28.262Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C语言实现分割字符串">
<meta name="twitter:description" content="背景遇到一个将字符串分割场景.以前从没有用c语言实现,都是使用python的split()函数,python处理起来很简单. split()方法语法： str.split(str=&amp;quot;&amp;quot;, num=string.count(str)). • str -- 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。 • num -- 分割次数。 返回分割后的字符串列表。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://githubmota.github.io/2017/12/29/2017-12-29-Linux-C-Split/"/>





  <title>C语言实现分割字符串 | Mota's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mota's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Every flight start at floor!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://githubmota.github.io/2017/12/29/2017-12-29-Linux-C-Split/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mota">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mota's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C语言实现分割字符串</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-29T17:54:09+08:00">
                2017-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程之道/" itemprop="url" rel="index">
                    <span itemprop="name">编程之道</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/29/2017-12-29-Linux-C-Split/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/12/29/2017-12-29-Linux-C-Split/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/12/29/2017-12-29-Linux-C-Split/" class="leancloud_visitors" data-flag-title="C语言实现分割字符串">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>遇到一个将字符串分割场景.以前从没有用c语言实现,都是使用python的split()函数,python处理起来很简单.</p>
<p>split()方法语法：</p>
<pre><code>str.split(str=&quot;&quot;, num=string.count(str)).
• str -- 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。
• num -- 分割次数。
返回分割后的字符串列表。
用例:
#!/usr/bin/python
str = &quot;Line1-abcdef \nLine2-abc \nLine4-abcd&quot;;
print str.split( );
print str.split(&apos; &apos;, 1 );
以上实例输出结果如下：
[&apos;Line1-abcdef&apos;, &apos;Line2-abc&apos;, &apos;Line4-abcd&apos;]
[&apos;Line1-abcdef&apos;, &apos;\nLine2-abc \nLine4-abcd&apos;]
</code></pre><p>Python split()通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串</p>
<h2 id="C语言扩展"><a href="#C语言扩展" class="headerlink" title="C语言扩展"></a>C语言扩展</h2><p>那使用C语言如何实现？</p>
<p>网上搜索到有个strtok函数具有分割字符串功能，信息如下</p>
<pre><code># man strtok
char *strtok(char *str, const char *delim);
The  strtok()  function  breaks a string into a sequence of zero or more nonempty tokens.  On the first call to strtok() the
string to be parsed should be specified in str.  In each subsequent call that should parse the same string, str must be NULL.

C语言实现python中的split函数:
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// 将str字符以spl分割,存于dst中，并返回子字符串数量
int split(char dst[][80], char* str, const char* spl)
{
    int n = 0;
    char *result = NULL;
    result = strtok(str, spl);
    while( result != NULL )
    {
        strcpy(dst[n++], result);
        result = strtok(NULL, spl);
    }
    return n;
}

int main()
{
    char str[] = &quot;what is your name?&quot;;
    char dst[10][80];
    int cnt = split(dst, str, &quot; &quot;);
    for (int i = 0; i &lt; cnt; i++)
        puts(dst[i]);
    return 0;
}
</code></pre><p>开始时strtok第一次调用str传入需分割的字符串,返回第一段分割出来的字符串”what”的地址(以’\0’结尾)，后续调用str为NULL，依次返回后续分割<br>字符串”is””your””name?”的地址.</p>
<p>到这里感觉有点奇怪，为什么后续str为NULL还能继续对”what is your name?”进行分割，它与第一次调用的关联在哪里?</p>
<h2 id="strtok源码分析"><a href="#strtok源码分析" class="headerlink" title="strtok源码分析"></a>strtok源码分析</h2><p>下载c语言标准库源码:</p>
<pre><code>git clone git://sourceware.org/git/glibc.git
cd glibc
git checkout --track -b local_glibc-2.26 origin/release/2.26/master
</code></pre><p><code>Strtok.c</code>:</p>
<pre><code>char * strtok (char *s, const char *delim)
{
  static char *olds;//初始为0，每次调用strtok_r后设置成下一次带分割字符串地址
  return __strtok_r (s, delim, &amp;olds);
}
</code></pre><p><code>Strtok_r.c</code>:</p>
<pre><code>#ifndef _LIBC
/* Get specification.  */
# include &quot;strtok_r.h&quot;
# define __strtok_r strtok_r //可直接使用strtok_r()函数分割字符串
#endif

char * __strtok_r (char *s, const char *delim, char **save_ptr)
{
  char *end;

  if (s == NULL) //后续分割字符串时str设置为NULL，使用上次存储在static变量中的地址
    s = *save_ptr;

  if (*s == &apos;\0&apos;)  //待分割字符串已到末尾，结束并返回NULL
    {
      *save_ptr = s;
      return NULL;
    }

  /* Scan leading delimiters.  */
  s += strspn (s, delim); //跳过直到第一个非分隔符的地址或字符串结尾
  if (*s == &apos;\0&apos;) //待分割字符串已到末尾，结束并返回NULL
    {
      *save_ptr = s;
      return NULL;
    }

  /* Find the end of the token.  */
  end = s + strcspn (s, delim); //跳过直到第一个分隔符地址或字符串结尾
  if (*end == &apos;\0&apos;) //待分割字符串已到末尾，结束并返回最后一个分割完的字符串
    {
      *save_ptr = end;
      return s;
    }

  /* Terminate the token and make *SAVE_PTR point past it.  */
  *end = &apos;\0&apos;; //分割好的字符串末尾置为终止符
  *save_ptr = end + 1; //保存下一次待分割字符串地址
  return s; //返回本次分割完的字符串
}
</code></pre><p>可以看到原来strtok()使用static变量存放下一次待分割字符串的地址,当传入str为NULL时使用该地址继续分割,<br>即后续strtok()调用是通过static变量与第一次strtok()关联的.</p>
<h2 id="strtok与strtok-r"><a href="#strtok与strtok-r" class="headerlink" title="strtok与strtok_r"></a>strtok与strtok_r</h2><p>手册里提到strtok()是非线程安全的:</p>
<pre><code>ATTRIBUTES
For an explanation of the terms used in this section, see attributes(7).
┌───────────┬───────────────┬───────────────────────┐
│Interface  │ Attribute     │ Value                 │
├───────────┼───────────────┼───────────────────────┤
│strtok()   │ Thread safety │ MT-Unsafe race:strtok │
├───────────┼───────────────┼───────────────────────┤
│strtok_r() │ Thread safety │ MT-Safe               │
└───────────┴───────────────┴───────────────────────┘
</code></pre><p>因为根据其定义，strtok()必须使用内部静态变量来记录字符串中下一个需要解析的标记的当前位置。但是，由于指示这个位置的变量只有一个，那么，在同一个程序中出现多个解析不同字符串的strtok调用时，各自的字符串的解析就会互相干扰。</p>
<p>POSIX定义了一个线程安全的函数——<code>strtok_r</code>，以此来代替strtok</p>
<p>带有_r的函数主要来自于UNIX下面。 所有的带有_r和不带_r的函数的区别的是：带_r的函数是线程安全的，r的意思是reentrant，可重入的</p>
<p>另外要注意的是<code>strtok</code>和<code>strtok_r</code>均对字符串本身做了修改，将分隔符替换成’\0’了</p>
<h2 id="strtok进阶-strsep"><a href="#strtok进阶-strsep" class="headerlink" title="strtok进阶:strsep"></a>strtok进阶:strsep</h2><p>搜索strtok字符串时，在<code>linux kernel(4.14.9 version)</code>源码文件string.c中看到文件开始的注释里提到:</p>
<pre><code>* * Fri Jun 25 1999, Ingo Oeser &lt;ioe@informatik.tu-chemnitz.de&gt;
 * -  Added strsep() which will replace strtok() soon (because strsep() is
  *    reentrant and should be faster). Use only strsep() in new code, please.
</code></pre><p>即新code建议使用strsep替换strtok,由于前者可重入且更快…1999年时就建议用strsep()了，结果在网上一搜分割字符串还都是strtok()…</p>
<p>查看strsep手册及用法</p>
<pre><code>#man strsep
char *strsep(char **stringp, const char *delim);
用法:
#include &lt;stdio.h&gt;  
#include &lt;string.h&gt;  

int main(void) {  
    char source[] = &quot;hello, world! welcome to china!&quot;;  
    char delim[] = &quot; ,!&quot;;  

    char *s = strdup(source);  
    char *token;  
    for(token = strsep(&amp;s, delim); token != NULL; token = strsep(&amp;s, delim)) {  
        printf(token);  
        printf(&quot;+&quot;);  
    }  
    printf(&quot;\n&quot;);  
    return 0;  
}  
//output: hello++world++welcome+to+china++
</code></pre><p>对比strtok用法:</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;string.h&gt;  

int main(void) {  
    char s[] = &quot;hello, world! welcome to china!&quot;;  
    char delim[] = &quot; ,!&quot;;  

    char *token;  
    for(token = strtok(s, delim); token != NULL; token = strtok(NULL, delim)) {  
        printf(token);  
        printf(&quot;+&quot;);  
    }  
    printf(&quot;\n&quot;);  
    return 0;  
}  
//output: hello+world+welcome+china+
</code></pre><p>二者第一个参数有差别: 由于strsep()执行完需要改变字符串s的地址以指向下一次分割开始,所以传递字符串s地址的指针</p>
<p>二者输出也有些差别，出现连续++的打印是因为中间输出了空字符串，在strsep()中碰到连续分隔符时会认为<br>分隔符之间有空字符串(这一点与python的split是一致的),详见<a href="#strsep">strsep源码</a></p>
<p>而strtok()会使用<code>s += strspn (s, delim);</code>跳过直到第一个非分隔符的地址或字符串结尾,而不会分割出空字符串.</p>
<h2 id="strsep源码分析"><a href="#strsep源码分析" class="headerlink" title="strsep源码分析"></a>strsep源码分析</h2><p><span id="strsep">源码如下</span></p>
<pre><code>char * __strsep (char **stringp, const char *delim)
{
  char *begin, *end;

  begin = *stringp;
  if (begin == NULL) //处理为NULL情况
    return NULL;

  /* Find the end of the token.  */
  end = begin + strcspn (begin, delim); //跳过直到第一个分隔符地址或字符串结尾

  if (*end) //若为分隔符则将其设置为&apos;\0&apos;，并将下次开始分割的地址赋值为end+1
    {
      /* Terminate the token and set *STRINGP past NUL character.  */
      *end++ = &apos;\0&apos;;
      *stringp = end;
    }
  else //若为字符串结尾则将下次开始分割的地址赋值为NULL,下次处理直接返回NULL
    /* No more delimiters; this is the last token.  */
    *stringp = NULL;

  return begin; //返回分割字符串地址
}
</code></pre><h2 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h2><p><code>strsep(),strtok(),strtok_r()</code>三者都需注意:</p>
<pre><code>函数会对传入的第一个参数即待分割字符串进行修改,即把分隔符替换成&apos;\0&apos;,由于该原因所以参数不能指向只读字符串.
</code></pre><p>所以通常的做法是把待分割字符串拷贝一份来处理,如上面用法中strdup的使用.</p>
<h2 id="strspn源码分析"><a href="#strspn源码分析" class="headerlink" title="strspn源码分析"></a>strspn源码分析</h2><p>strtok函数中使用到strspn()来定位非分隔符地址.</p>
<pre><code>Strspn.c:
/* Return the length of the maximum initial segment
of S which contains only characters in ACCEPT.  */
size_t STRSPN (const char *str, const char *accept)
{
  if (accept[0] == &apos;\0&apos;)
    return 0;
  if (__glibc_unlikely (accept[1] == &apos;\0&apos;)) //分支预测优化
    {
      const char *a = str;
      for (; *str == *accept; str++);
      return str - a;
    }

//测试了下分开的时间是不分开的2倍，不理解。
//从代码本身注释看memset 64个字节可以直接在此处将memset函数当内联函数展开？
  /* Use multiple small memsets to enable inlining on most targets.  */
  unsigned char table[256];
  unsigned char *p = memset (table, 0, 64);
  memset (p + 64, 0, 64);
  memset (p + 128, 0, 64);
  memset (p + 192, 0, 64);

  unsigned char *s = (unsigned char*) accept;
  /* Different from strcspn it does not add the NULL on the table
     so can avoid check if str[i] is NULL, since table[&apos;\0&apos;] will
     be 0 and thus stopping the loop check.  */
  do
    p[*s++] = 1; //将分隔符对应index处置1
  while (*s);

  s = (unsigned char*) str;
  if (!p[s[0]]) return 0;
  if (!p[s[1]]) return 1;
  if (!p[s[2]]) return 2;
  if (!p[s[3]]) return 3;

  //宏定义PTR_ALIGN_DOWN将向下找到与4字节对齐的地址返回
  //PTR_ALIGN_DOWN (0x3, 4); return 0x0
  //PTR_ALIGN_DOWN (0x4, 4); return 0x4
  //PTR_ALIGN_DOWN (0x5, 4); return 0x4
  s = (unsigned char *) PTR_ALIGN_DOWN (s, 4);

  unsigned int c0, c1, c2, c3;
  do {
      s += 4;
      c0 = p[s[0]];
      c1 = p[s[1]];
      c2 = p[s[2]];
      c3 = p[s[3]];
  } while ((c0 &amp; c1 &amp; c2 &amp; c3) != 0);

  size_t count = s - (unsigned char *) str;
 //此处为何不直接return count+c0+c1+c2,估计涉及到编译优化吧
  return (c0 &amp; c1) == 0 ? count + c0 : count + c2 + 2;
}
</code></pre><h2 id="计时统计"><a href="#计时统计" class="headerlink" title="计时统计"></a>计时统计</h2><p>统计strspn中耗时使用如下代码</p>
<pre><code>struct timeval t_val;
gettimeofday(&amp;t_val, NULL);

//write your process here

struct timeval t_val_end;
gettimeofday(&amp;t_val_end, NULL);
struct timeval t_result;
timersub(&amp;t_val_end, &amp;t_val, &amp;t_result);
double consume = t_result.tv_sec + (1.0 * t_result.tv_usec)/1000000;
printf(&quot;end.elapsed time= %fs \n&quot;, consume);
</code></pre><h2 id="strtok源码NetBSD及微软实现"><a href="#strtok源码NetBSD及微软实现" class="headerlink" title="strtok源码NetBSD及微软实现"></a>strtok源码NetBSD及微软实现</h2><p>来源于某博客<a href="http://www.cppblog.com/yinquan/archive/2009/06/01/86411.html" target="_blank" rel="noopener">C库源代码NetBSD及微软实现: strtok</a></p>
<p>NetBSD简单粗暴地遍历，而微软通过32bytes的空间将时间复杂度降至N，比glibc中256bytes空间利用率高</p>
<h2 id="C语言实现split"><a href="#C语言实现split" class="headerlink" title="C语言实现split"></a>C语言实现split</h2><p>C语言分割字符串可使用strsep(),最好复制一份进行分割.</p>
<pre><code>#include&lt;stdio.h&gt;
#include &lt;string.h&gt;  

int split(char *str, const char *delim, char dst[][80]) {
    char *s = strdup(str);  
    char *token;  
    int n = 0;
    for(token = strsep(&amp;s, delim); token != NULL; token = strsep(&amp;s, delim)) {  
        strcpy(dst[n++], token);
    }  
    return n;
}

int main(void) {  
    char source[] = &quot;hello, world! welcome to china!&quot;;  
    char delim[] = &quot; ,!&quot;;  
    char dst[10][80];
    int cnt = split(source, delim, dst);
    for (int i = 0; i &lt; cnt; i++)
        printf(&quot;%s\n&quot;,dst[i]);
    return 0;  
}  
</code></pre><p>python的split()是返回分割字符串数组的，上面实现这个返回的动态数组比较困难,用固定的<code>dst[10][80]</code>…限制太多</p>
<p>还是C++的动态数组vector好用…</p>
<h2 id="C-实现split"><a href="#C-实现split" class="headerlink" title="C++实现split"></a>C++实现split</h2><p>使用substr()定位分隔符,vector的<code>push_back()</code>动态插入分割子字符串</p>
<pre><code>//字符串分割函数
std::vector&lt;std::string&gt; split(std::string str,std::string pattern)
{
    std::string::size_type pos;
    std::vector&lt;std::string&gt; result;
    str+=pattern;//扩展字符串以方便操作
    int size=str.size();

    for(int i=0; i&lt;size; i++)
    {
        pos=str.find(pattern,i);
        if(pos&lt;size)
        {
            std::string s=str.substr(i,pos-i);
            result.push_back(s);
            i=pos+pattern.size()-1;
        }
    }
    return result;
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C语言实现split()可以使用strsep(),但还是不好用，能用python处理最好，应用C++也是不错的.</p>
<p>libc库底层的实现有很多优化的思想…拜一拜…</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.runoob.com/python/att-string-split.html" target="_blank" rel="noopener">python split使用文档</a></p>
<p><a href="http://blog.csdn.net/ixidof/article/details/5154016" target="_blank" rel="noopener">线程安全——strtok VS strtok_r</a></p>
<p><a href="http://blog.csdn.net/yafeng_jiang/article/details/7109285" target="_blank" rel="noopener">strtok和strsep函数详解</a></p>
<p><a href="https://stackoverflow.com/questions/109710/likely-unlikely-macros-in-the-linux-kernel-how-do-they-work-whats-their" target="_blank" rel="noopener">likely()/unlikely() macros in the Linux kernel - how do they work?benefit?</a></p>
<p><a href="https://www.cnblogs.com/MikeZhang/archive/2012/03/24/MySplitFunCPP.html" target="_blank" rel="noopener">字符串分割(C++)</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C-C/" rel="tag"># C/C++</a>
          
            <a href="/tags/python/" rel="tag"># python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/27/2017-12-27-Optane-SSD-Memory-Benchmark/" rel="next" title="Optane SSD虚拟内存Redis性能测试">
                <i class="fa fa-chevron-left"></i> Optane SSD虚拟内存Redis性能测试
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/05/2018-02-05-Optane-SSD-Memory-Benchmark-2/" rel="prev" title="Optane SSD虚拟内存(IMDT)与DRAM性能对比">
                Optane SSD虚拟内存(IMDT)与DRAM性能对比 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mota</p>
              <p class="site-description motion-element" itemprop="description">描述</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#背景"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C语言扩展"><span class="nav-number">2.</span> <span class="nav-text">C语言扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strtok源码分析"><span class="nav-number">3.</span> <span class="nav-text">strtok源码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strtok与strtok-r"><span class="nav-number">4.</span> <span class="nav-text">strtok与strtok_r</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strtok进阶-strsep"><span class="nav-number">5.</span> <span class="nav-text">strtok进阶:strsep</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strsep源码分析"><span class="nav-number">6.</span> <span class="nav-text">strsep源码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用注意事项"><span class="nav-number">7.</span> <span class="nav-text">使用注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strspn源码分析"><span class="nav-number">8.</span> <span class="nav-text">strspn源码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计时统计"><span class="nav-number">9.</span> <span class="nav-text">计时统计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strtok源码NetBSD及微软实现"><span class="nav-number">10.</span> <span class="nav-text">strtok源码NetBSD及微软实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C语言实现split"><span class="nav-number">11.</span> <span class="nav-text">C语言实现split</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-实现split"><span class="nav-number">12.</span> <span class="nav-text">C++实现split</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">13.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">14.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mota</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'tqMuXfk01RdlpraEg66XYaOg-gzGzoHsz',
        appKey: 'pg4fMhGi1elBvKSMjmHEM2v7',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("tqMuXfk01RdlpraEg66XYaOg-gzGzoHsz", "pg4fMhGi1elBvKSMjmHEM2v7");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

  
  <!-- custom analytics part create by xiamo -->
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("tqMuXfk01RdlpraEg66XYaOg-gzGzoHsz", "pg4fMhGi1elBvKSMjmHEM2v7");</script>
<script>
function showTime(Counter) {
	var query = new AV.Query(Counter);
	$(".leancloud_visitors").each(function() {
		var url = $(this).attr("id").trim();
		query.equalTo("url", url);
		query.find({
			success: function(results) {
				if (results.length == 0) {
					var content = '0 ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
					return;
				}
				for (var i = 0; i < results.length; i++) {
					var object = results[i];
					var content = object.get('time') + ' ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
				}
			},
			error: function(object, error) {
				console.log("Error: " + error.code + " " + error.message);
			}
		});

	});
}

function addCount(Counter) {
	var Counter = AV.Object.extend("Counter");
	url = $(".leancloud_visitors").attr('id').trim();
	title = $(".leancloud_visitors").attr('data-flag-title').trim();
	var query = new AV.Query(Counter);
	query.equalTo("url", url);
	query.find({
		success: function(results) {
			if (results.length > 0) {
				var counter = results[0];
				counter.fetchWhenSave(true);
				counter.increment("time");
				counter.save(null, {
					success: function(counter) {
						var content =  counter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(counter, error) {
						console.log('Failed to save Visitor num, with error message: ' + error.message);
					}
				});
			} else {
				var newcounter = new Counter();
				newcounter.set("title", title);
				newcounter.set("url", url);
				newcounter.set("time", 1);
				newcounter.save(null, {
					success: function(newcounter) {
					    console.log("newcounter.get('time')="+newcounter.get('time'));
						var content = newcounter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(newcounter, error) {
						console.log('Failed to create');
					}
				});
			}
		},
		error: function(error) {
			console.log('Error:' + error.code + " " + error.message);
		}
	});
}
$(function() {
	var Counter = AV.Object.extend("Counter");
	if ($('.leancloud_visitors').length == 1) {
		addCount(Counter);
	} else if ($('.post-title-link').length > 1) {
		showTime(Counter);
	}
}); 
</script>

  
</body>
</html>
